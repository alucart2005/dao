---
description: Performance optimization patterns for React components and smart contracts
globs: **/*.tsx,**/*.ts,**/*.sol
---

# Performance Optimization

## React Performance

### Memoization

Use `React.memo` for expensive components:

```typescript
import { memo } from "react";

export const ProposalCard = memo(function ProposalCard({
  proposalId,
  proposal,
}: {
  proposalId: bigint;
  proposal: Proposal;
}) {
  // Component implementation
});
```

### useMemo for Expensive Calculations

```typescript
const totalVotes = useMemo(() => {
  return proposals.reduce((sum, p) => sum + p.votesFor + p.votesAgainst, 0n);
}, [proposals]);
```

### useCallback for Stable References

```typescript
const handleVote = useCallback(
  (proposalId: bigint, voteType: 0 | 1 | 2) => {
    vote(proposalId, voteType);
  },
  [vote]
);
```

### Lazy Loading Components

```typescript
import { lazy, Suspense } from "react";

const ProposalList = lazy(() => import("@/components/ProposalList"));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <ProposalList />
    </Suspense>
  );
}
```

### Code Splitting

Next.js automatically code-splits, but you can optimize:

```typescript
// Dynamic imports for heavy components
import dynamic from "next/dynamic";

const HeavyChart = dynamic(() => import("@/components/HeavyChart"), {
  loading: () => <div>Loading chart...</div>,
  ssr: false, // Disable SSR if not needed
});
```

## Wagmi Query Optimization

### Disable Unnecessary Refetches

```typescript
const { data: balance } = useReadContract({
  address: CONTRACTS.DAO_VOTING,
  abi: DAO_VOTING_ABI,
  functionName: "balanceOf",
  args: [address],
  query: {
    // Only refetch every 30 seconds
    refetchInterval: 30000,
    // Don't refetch on window focus
    refetchOnWindowFocus: false,
    // Cache for 5 minutes
    staleTime: 5 * 60 * 1000,
  },
});
```

### Batch Contract Reads

Read multiple values in parallel:

```typescript
const { data: balance } = useReadContract({ /* ... */ });
const { data: totalBalance } = useReadContract({ /* ... */ });
const { data: proposalCount } = useReadContract({ /* ... */ });

// All queries run in parallel, not sequentially
```

### Conditional Queries

Only query when needed:

```typescript
const { data: proposal } = useReadContract({
  address: CONTRACTS.DAO_VOTING,
  abi: DAO_VOTING_ABI,
  functionName: "getProposal",
  args: [proposalId],
  query: {
    // Only query if proposalId is valid
    enabled: !!proposalId && proposalId >= 0n,
  },
});
```

## Smart Contract Gas Optimization

### Storage Optimization

```solidity
// ❌ BAD - Wastes storage slots
struct Proposal {
    uint128 amount;      // Slot 1 (half used)
    uint128 unused;      // Slot 1 (wasted)
    uint256 deadline;    // Slot 2
}

// ✅ GOOD - Packs efficiently
struct Proposal {
    uint128 amount;      // Slot 1
    uint128 deadline;    // Slot 1 (if timestamp fits)
    address recipient;   // Slot 2 (20 bytes, 12 bytes padding)
}
```

### Loop Optimization

```solidity
// ❌ BAD - Storage reads in loop
function getTotalBalance() external view returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 0; i < users.length; i++) {
        total += balances[users[i]]; // Storage read each iteration
    }
    return total;
}

// ✅ GOOD - Cache storage reads
function getTotalBalance() external view returns (uint256) {
    uint256 total = 0;
    address[] memory usersList = users; // Copy to memory
    for (uint256 i = 0; i < usersList.length; i++) {
        total += balances[usersList[i]];
    }
    return total;
}
```

### Use Events Instead of Storage

```solidity
// ❌ BAD - Stores all votes
mapping(uint256 => mapping(address => Vote)) public votes;

// ✅ GOOD - Emit events, calculate on frontend
event Voted(uint256 indexed proposalId, address indexed voter, uint8 voteType);
```

### Batch Operations

```solidity
// ✅ GOOD - Batch multiple operations
function batchVote(
    uint256[] calldata proposalIds,
    uint8[] calldata voteTypes
) external {
    require(proposalIds.length == voteTypes.length, "Length mismatch");
    for (uint256 i = 0; i < proposalIds.length; i++) {
        vote(proposalIds[i], voteTypes[i]);
    }
}
```

## Frontend Optimization

### Image Optimization

```typescript
import Image from "next/image";

// Next.js automatically optimizes images
<Image
  src="/logo.png"
  alt="DAO Logo"
  width={200}
  height={200}
  priority // For above-the-fold images
/>
```

### Reduce Bundle Size

```typescript
// ✅ GOOD - Import only what you need
import { formatEther } from "viem/utils";

// ❌ BAD - Import entire library
import * as viem from "viem";
```

### Virtual Scrolling for Long Lists

For long proposal lists:

```typescript
import { useVirtualizer } from "@tanstack/react-virtual";

function ProposalList({ proposals }: { proposals: Proposal[] }) {
  const parentRef = useRef<HTMLDivElement>(null);
  
  const virtualizer = useVirtualizer({
    count: proposals.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 200, // Estimated item height
  });

  return (
    <div ref={parentRef} style={{ height: "600px", overflow: "auto" }}>
      {virtualizer.getVirtualItems().map((virtualItem) => (
        <div key={virtualItem.key} style={{ height: virtualItem.size }}>
          <ProposalCard proposal={proposals[virtualItem.index]} />
        </div>
      ))}
    </div>
  );
}
```

### Debounce User Input

```typescript
import { useDebouncedCallback } from "use-debounce";

function SearchProposals() {
  const [search, setSearch] = useState("");
  
  const debouncedSearch = useDebouncedCallback((value: string) => {
    // Perform search
    searchProposals(value);
  }, 300);

  return (
    <input
      value={search}
      onChange={(e) => {
        setSearch(e.target.value);
        debouncedSearch(e.target.value);
      }}
    />
  );
}
```

## API Route Optimization

### Response Caching

```typescript
export async function GET(request: Request) {
  // Cache response for 60 seconds
  return NextResponse.json(data, {
    headers: {
      "Cache-Control": "public, s-maxage=60, stale-while-revalidate=300",
    },
  });
}
```

### Database Query Optimization

If using a database later:

```typescript
// ✅ GOOD - Use indexes, limit results
const proposals = await db.proposals
  .findMany({
    where: { status: "active" },
    take: 20, // Limit results
    orderBy: { createdAt: "desc" },
  });

// ❌ BAD - Fetch all, filter in memory
const allProposals = await db.proposals.findMany();
const active = allProposals.filter((p) => p.status === "active");
```

## Monitoring Performance

### React DevTools Profiler

Use React DevTools to identify slow renders:

1. Open React DevTools
2. Go to Profiler tab
3. Record a session
4. Identify components with long render times

### Web Vitals

Monitor Core Web Vitals:

```typescript
// app/layout.tsx
import { Analytics } from "@vercel/analytics/react";

export default function RootLayout() {
  return (
    <html>
      <body>
        {children}
        <Analytics />
      </body>
    </html>
  );
}
```

## Best Practices

1. **Measure first** - Don't optimize prematurely
2. **Profile before optimizing** - Use tools to find bottlenecks
3. **Optimize critical paths** - Focus on user-facing code
4. **Test after optimization** - Ensure correctness isn't lost
5. **Document optimizations** - Explain why you made changes
6. **Balance readability** - Don't sacrifice clarity for micro-optimizations

## Performance Checklist

- [ ] Components memoized where appropriate
- [ ] Expensive calculations use `useMemo`
- [ ] Callbacks use `useCallback`
- [ ] Large lists use virtualization
- [ ] Images optimized
- [ ] Bundle size analyzed
- [ ] Contract gas usage optimized
- [ ] API responses cached
- [ ] Database queries optimized (if applicable)
- [ ] Performance metrics monitored
